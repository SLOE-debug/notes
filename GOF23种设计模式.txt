0.高内聚 低耦合、设计原则
	高内聚：将一些依赖比较紧密的方法实现在一个类中
	低耦合：当实现了高内聚那么就达到了低耦合
	
	设计原则:
		单一职责原则：一个类只负责一个功能领域中的相应职责
		
		依赖倒置原则：
			高层模块不应该依赖于低层模块,二者都应该依赖于抽象
			抽象对象不应该依赖于细节,细节应当依赖于抽象
			
			总之：要依赖抽象类编程,而不是面向实现编程
			
		开闭原则：实体应对扩展开放,对修改关闭,即实体应尽量在不修改源代码的基础上进行扩展
		
		接口隔离原则：使用多个专门的接口,而不是使用单一的总接口
		
		里氏替换原则：所有的基类出现的地方必定能被子类替换,且功能不发生任何影响
		
		合用复用原则：尽量使用对象组合/聚合,而不是继承来达到复用的目的
		
		迪米特原则：两个实体之间不出现互相调用的代码,而是存在第三者通讯,只与直接的朋友通讯,不跟陌生人说话
		
1.简单工厂模式（反模式，非设计模式的一种）
	将一个类中的变化,隔离出来,建成一个静态类,通过配置文件来动态更改返回的值,被称为简单工厂模式
	
	优点：
		实现了对责任的分割,隔离了变化,因为它提供了专门的工厂类用于创建对象
		通过配置文件,可以不修改任何客户端代码的情况下更换和修改新的具体产品类,在一定程度上提高了系统的灵活性
		
	缺点：
		集中了所有实例的创建逻辑,违反了单一职责
		扩展困难,一旦添加新的产品不得不修改工厂逻辑,违反了开闭原则
		
2.工厂模式
	定义一个工厂父类,工厂父类定义创建对象的公共接口,而子类负责生成具体的对象,即将类的实例化抛出在子类中完成,新增类型添加子类,让子类来决定实例化哪个类型
	
	优点：符合设计原则
	
	缺点：类的个数成倍增加,增加系统复杂度,增加其他工厂等于(1*n)
	
3.抽象工厂模式
	把工厂模式中的父类抽象化,即抽象工厂模式
	
	优点：为工厂模式的升级版,为相关或者相互依赖的独享提供一个统一的接口,而且无需指定他们的具体实现类,即对产品族进行了约束,封装性好
	
	缺点：扩展产品族困难,添加一个产品需要修改抽象和具体工厂类,违反了开闭原则
	
4.单例模式
	全局唯一、全局共享
	
	优点：确保全局共享一个实例、节约系统资源
	
	将单例类的构造函数设成私有或受保护的,让外部代码不能直接创建单例类,将获取单例类的方法暴露出去,在单例类中创建单例类
	
	高并发单例：
		最好使用双检索的方式来判断该单例是否是存在的
		volatile 关键字：告诉编译器不会按照优化的方式来，解决高并发时单例会出现两次 new 的情况
		使用懒加载单例,就不需要已上两点了
	
	高并发操作数字：Interlocked(https://www.cnblogs.com/yy1234/p/11159177.html)
	
	懒加载单例：
		Lazy<T> 将对象的初始化延时到第一次使用该对象的时候
	
	多个单例时：
		创建单例基类,通过泛型的方式传入类型创建单例,单例基类中还是使用懒加载单例
	
5.建造者模式
	建造者模式是将一个复杂的对象构建与它的表示分离,使得同样的构建过程可以创建不同的表示,建造者模式隐藏了复杂对象的创建过程,他把复杂对象的创建过程加以抽象,通过子类继承或重载的方式,动态的创建复杂的、具有复合属性的对象
	
	优点：一定程度上,消除了类爆炸问题、职责分离,由单独的生产线组装手机
	
	缺点：配置变得固定了,不能随意组合、对大多数场景依然过于复杂,比如,未必每一个配置的手机都需要一个生产线,组装手机也未必需要一个单独的生产线