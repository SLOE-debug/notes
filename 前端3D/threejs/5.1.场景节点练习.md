这里我们来实现一个坦克，那么这个坦克的结构为

* 场景
  * 坦克
    * 坦克主体，也就是驾驶舱，我们把所有的配件都装到驾驶舱上
      * 六个轮子
      * 炮台
        * 炮筒
        * 炮台上面放个摄像机
      * 坦克上面放个摄像机
  * 两个灯光
    * 一个从顶部照射
    * 一个从正Z方向照射来补光，要不然一个灯太暗了
  * 地面和坦克运行路线
  * 坦克的目标

开头老样子，咱们建场景对象、摄像机对象、渲染器对象、渲染器函数、响应函数、罗里吧嗦的，创建一个main函数，作为程序入口。

渲染器函数加了一个`time`参数，为当前渲染器从创建到现在的时间，会逐步增加的，自己测一下。

```typescript
let scene = new THREE.Scene();
let camera = new THREE.PerspectiveCamera(
  45,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 50;
let c = document.getElementById("c") as HTMLCanvasElement;
let renderer = new THREE.WebGLRenderer({
  canvas: c,
});
renderer.setClearColor("#C4C4C4");

function ResetSize() {
  let ratio = window.devicePixelRatio
  let w = c.clientWidth * ratio;
  let h = c.clientHeight * ratio;
  let needReset = c.width !== w || c.height !== h;
  if (needReset) renderer.setSize(w, h, false);
  return needReset;
}

function render(time) {
  requestAnimationFrame(render);
  if (ResetSize()) {
    const canvas = renderer.domElement;
    camera.aspect = canvas.clientWidth / canvas.clientHeight;
    camera.updateProjectionMatrix();
  }
  renderer.render(scene, camera);
}
requestAnimationFrame(render);

function main() {
}
main();
```

#### 坦克壳子

这里的壳子也就是说是坦克外面包的`Object3D`，为的就是把坦克的东西给包起来，形成一个整体。

我懒，这里把坦克画成一个颜色的。所以我把`TankMater`提出来不用每次都创建了

```typescript
let wireframe = false;
let TankMater = new THREE.MeshPhongMaterial({
  color: "#68663D",
  wireframe,
});
function createTank() {
  let Tank = new THREE.Object3D();
  // 这个Body其实就是一个板子我们稍候来看一下
  let TankBody = new THREE.BoxGeometry(15, 1.5, 8);
  let TankBodyMesh = new THREE.Mesh(TankBody, TankMater);
  Tank.add(TankBodyMesh);
  return Tank;
}
function main() {
  scene.add(createTank());
}
```

#### 创建灯光，要不然太黑了

记得一定要有创建`Object3D`的习惯，把你认为是一体的部分包起来，但是具体要不要包，还得看实际情况。

```typescript
function createLight() {
  let light = new THREE.Object3D();
  let topLight = new THREE.DirectionalLight("", 1);
  topLight.position.set(0, 50, 0);
  light.add(topLight);
  let zIndexLight = new THREE.DirectionalLight("", 1);
  zIndexLight.position.set(5, 5, 5);
  light.add(zIndexLight);
  return light;
}
function main() {
  scene.add(createTank(), createLight());
}
```

好了，我们现在创建完灯光了，我们可以看到一个`野战军绿`颜色的板子，我们拿他来当坦克的主体部分，作为坦克的基础结构。

#### 创建地面

地面就是一个简简单单的正方形，比较矮的正方形。

我们待会再创建坦克行动路线，因为那个有点多，待会再讲。

```typescript
function createGround() {
  let Ground = new THREE.BoxGeometry(60, 1, 60);
  let GroundMater = new THREE.MeshPhongMaterial({
    color: "#67ABB8",
    wireframe,
  });
  let GroundMesh = new THREE.Mesh(Ground, GroundMater);
  return GroundMesh;
}
function main() {
  scene.add(createTank(), createLight(), createGround());
}
```

什么？看着难受？板板整整的？那换个方向

```typescript
// 把相机定位到X：-50，Y：40，Z：45的位置，这样你的视角是在远处的左侧向上一点的位置
camera.position.set(-50, 40, 45);
// 从相机当前位置看向0,0,0坐标点，也就是场景的正中心
camera.lookAt(0, 0, 0);
```

可以参照这个改动一下`X,Y,Z`的位置，可以有更多视角哦~

什么？坦克那个板子有一半到地面里去了？

我们来吧`Tank`对象抬上来

为什么抬板子厚度的两倍？我们是为了给轮子留点空间

```typescript
Tank.position.y = 3;
```

#### 创建6个轮子

我们用圆柱来做轮子，比较矮的圆柱，只不过圆柱的的段数比较少，所以我们看起来像方的，然后我们让圆柱旋转180°，让他从横着的变成竖着的。

因为我们要在`render`方法中让轮子们旋转起来，所以我们把`wheel`提出来成为一个数组，然后我们通过计算来让一侧三个轮子。

```typescript
let wheels: Array<THREE.Mesh> = [];
function createWheels() {
  let size = 2.5;
  for (let i = 0; i < 6; i++) {
    let wheel = new THREE.CylinderGeometry(size, size, 1.5, 8);
    let wheelMesh = new THREE.Mesh(wheel, TankMater);
    wheelMesh.rotation.x = Math.PI / 2;
    wheelMesh.position.set(
      (i % 3) * (size * 2) + -size * 2,
      0,
      i >= 3 ? -4 : 4
    );
    wheels.push(wheelMesh);
  }
  return wheels;
}
```

为了让轮子添加到`tankBody`内部，我们稍微改动一下`createTank`方法，并且为`Tank`和`TankBody`设置可以形成阴影和接收阴影。

```typescript
function createTank(...child: Array<THREE.Mesh | Array<THREE.Mesh>>){
  // ...
  child.forEach((c) => {
    if (Array.isArray(c)) {
      c.forEach((cc) => {
        cc.castShadow = true;
        cc.receiveShadow = true;
        TankBodyMesh.add(cc);
      });
    } else {
      c.castShadow = true;
      c.receiveShadow = true;
      TankBodyMesh.add(c);
    }
  });
  // ...
}
```

`castShadow`：可以形成阴影

`receiveShadow`：可以接收阴影，也就是说在其上方节点形成的阴影会不会显示在当前节点上面。

我们在`render`方法中添加代码让轮子转起来

```typescript
function render(time) {
  // ...
  wheels.forEach((w) => (w.rotation.y += 0.1));
  // ...
}
```

#### 创建炮台

我们用球体形状，做一个半球体，扣在板子上，然后做成一个类似炮台一样的东西。

```typescript
function createDome() {
  let dome = new THREE.SphereGeometry(6,20,20,0,Math.PI * 2,0,Math.PI / 2);
  let domeMesh = new THREE.Mesh(dome, TankMater);
  return domeMesh;
}
```

待续。。。
