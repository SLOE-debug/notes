1.Startup类
	理论：Startup 类可以用来定义请求处理管道和配置应用程序需要的服务

	Startup 类必须是公开的，且必须包含以下两个方法：
		ConfigureServices：方法用于定义应用程序所需要的服务，例如 ASP.NET Core MVC 、 Entity Framework Core 和 Identity 等等
		
		Configure：用于定义请求管道中的中间件
		
2.中间件
	中间件：1号中间件运行之后等待2号中间件运行,2号等待3号,直到遇到短路中间件时,2号等待3号运行完成之后,依次向上原路返回
	
	Run方法：
		app.Run() 方法允许我们传入另一个方法，我们可以用它来处理每一个单独的响应。Run() 方法不经常见，它是调用中间件的终端
		在 app.Run() 方法中注册的中间件永远不会有机会调用另一个中间件，它只会接收请求，然后必须产生某种响应
		app.Run() 方法中注册的中间件还可以访问 Response，例如使用 Response 对象返回一个字符串
		如果在 app.Run() 方法之后注册另一个中间件，那么注册的那个中间件永远不会被调用，因为 Run() 方法是注册中间件的 终端，在它之后，永远不会调用下一个中间件
	
	每个应用默认都会使用 context.Response.WriteAsync：
		app.Run(async (context) =>
		{
			await context.Response.WriteAsync("Hello World!");	--中间件
		});
		
    UseDeveloperExceptionPage：
		他不做任何响应,只关心后面的中间件是否出现异常,如果出现异常那么将抛出错误信息以及位置,
		如果将他注释掉,那么将抛出服务器500错误
	
	UseStaticFiles：
		除非我们覆盖选项并传递一些不同的配置参数，否则静态文件中间件执行的操作是针对给定的请求查看请求路径
		然后将此请求路径与文件系统以及文件系统上的内容进行比较
	
	UseDefaultFiles：
		指定默认起始页,要特别注意顺序, UseDefaultFiles 必须在 UseStaticFiles 之前,否则会提示出错
		他会根据这些名字查找默认文件 [index.html、index.htm、default.html、default.htm] ,不区分大小写
		如果没有找到上述文件,那么不好意思404错误
	
	UseFileServer：
		该中间件是对 UseStaticFiles 和 UseDefaultFiles 的封装,因为同时使用 UseStaticFiles 和 UseDefaultFiles ,很容易搞混
		只使用该中间件的结果和 UseStaticFiles、UseDefaultFiles 两个混合起来用是一样的
	
	UseMvcWithDefaultRoute：
		MVC路由中间件,他给了我们一个默认的路由规则,允许我们访问 HomeController
		该形式会调用UseMvc,通过硬编码设定默认路由,
		格式：{controller=Home}/{action=Index}/{id?}
		那么这个路由格式是写死的,如果想要设置固定格式路由,那么请使用 UseMvc();
		
	UseMvc:
		该中间件需要传入一个委托,可以自己写一个方法
		private void ConfigureRoute(IRouteBuilder routeBuilder)
		{
            //Home/Index 
            routeBuilder.MapRoute("Default", "{controller}/{action}/{id?}");
        }
		在方法中可以配置路由,然后调用中间件 UseMvc(ConfigureRoute) 注册路由
		
3.静态文件
	wwwroot：如果没有额外的配置,那么该文件夹将是应用程序中唯一可以存放静态文件的位置
	
	默认页面：
		非开发模式：IIS默认文件列表设置
	
		开发模式：
			采用中间件 UseDefaultFiles
			如果是MVC开发：
				用 UseMvcWithDefaultRoute 或者 UseMvc
	
4.MVC的开发
	理论：Net Core 2.1里面集成了MVC的程序集只需要注册相应的中间件和服务即可
	
	将项目改为MVC开发步骤：
		1.创建Controller文件夹
		2.创建HomeController控制器
		3.添加index方法
		4.注册中间件 UseMvcWithDefaultRoute
		5.注册MVC服务 services.AddMvc()
	
		运行即可看到页面...
	
	重要文件说明：
		查看NetCore源码：
			Git方式：F12定位方法查看类名,然后复制类名去微软官方的git仓库查找这个文件,然后再复制方法名到文件中搜索
			VS2019：工具-->选项-->代码编辑器-->C#-->高级
		Program.cs：
			基于WebHost的Net Core启动原理：
				CreateDefaultBuilder
					Startup类中 Configure 方法参数app和env的注入来源：在 WebHost.CreateDefaultBuilder 方法内,实例化了 WebHostBuild 类,在该类中注入了 serviceCollection.AddTransient<IApplicationBuilder> 工厂
					当实例化 WebHostBuild 类后
					调用 UseContentRoot：设置静态资源和动态资源的目录(要去哪里寻找视图、js、css、img文件)
					调用 UseConfiguration：该方法是获取命令行运行时的参数,带入到 Startup 类中
					调用 UseKestrel：该方法是在程序内部运行 Kestrel 作为自身的 HttpServer 来处理 HTTP 请求
					调用 ConfigureAppConfiguration：获取 appsettings.json 配置信息
						 上级调用 AddUserSecrets：如果这是一个开源项目,每个人拷贝下来,都有每个人的服务器、SSO、或者私钥的配置,那么就可以通过右键项目-->管理用户机密来设置这些信息,当然,这些信息并不会上传到git仓库
						 上级调用 AddEnvironmentVariables：环境变量
					调用 ConfigureLogging：该方法是日志,添加了配置文件中的服务日志、控制台、DeBug、事件日志
					调用 ConfigureServices：该方法进行 Startup 类中同名方法进行服务处理并配置一下方法内的默认配置,即服务注入
				
				UseStartup<Startup>()：在此方法中注入服务、中间件
				
				Run：当启动之后,会阻塞调用线程直到程序关闭,控制台中的提示消息也是在该方法中提示的
				
		Startup.cs：
			配合program做一些独立配置的一些文件
		
		进程内和进程外：
			在此的进程指的是 IIS Express Worker Process
			进程内：Net Core 进程内(inProcess)托管,进程内托管可依靠 IIS 获得更高的吞吐量
			进程外：Net Core 进程外(out of Process)托管,使用内部的 kestrel
			
			在Core项目的 csproj 文件中 会有一个叫做 AspNetCoreHostingModel 的节点,值有 InProcess 和 OutOfProcess 两种选择,当值为 OutOfProcess 时,如果还是以IIS启动的话,因为 kestrel 是要配合一个反向代理服务器使用的,那么此时IIS会变成反向代理服务器的形式运行,验证IIS时反向代理服务器还是应用服务器,在客户端(也就是浏览器)查看NetWork请求,在 Response 的请求中会有一个 Server：kestrel 表示当前应用服务器是 kestrel
			
			进程内托管问题：在本地可以完美运行,但发布到IIS就无法运行了,大多是路径问题,因为进程外托管的话,整个目录是在dotnet执行时确定的,进程内的话,因为w3we.exe文件在C盘,所以容易出现路径不对的问题,所以尽量使用进程外运行
		
	JWT鉴权：
		我们来看一下JWT的流程：
			服务端颁发 ToKen -->客户端访问API携带 ToKen 也就是在Header中携带键为 Authorization 值为 Bearer ToKen值-->服务端效验
			上面流程的在 Net Framework MVC 中,需要一个过滤器并在方法或者控制器上方打上自定义特性标记([JWTattr])来效验JWT,而在 Net Core 中,是以中间件的方式来的,请参考以下代码
			颁发 Token：
														  此处的方法是将 JwtSecurityToken 对象来输出成一个ToKen
				var token = new JwtSecurityTokenHandler().WriteToken(new JwtSecurityToken(		--JwtSecurityToken 对象是用来配置 声明(Payload)、颁发者(issuer)、订阅者(audience)、有效时间(expires)、数字签名[也就是对JWT的算法(signingCredentials)]
					claims: new Claim[] {	--在这里 Claim 的类型有两种、ClaimTypes(微软内置的 Payload 字段名)、JwtRegisteredClaimNames(JWT内置封装的 Payload 字段名)
						new Claim(ClaimTypes.Name,"balabala"),
						new Claim(JwtRegisteredClaimNames.Email,"balabala@qq.com"),
						new Claim(JwtRegisteredClaimNames.Sid,"1001"),
						new Claim(ClaimTypes.Role,"Staff")
					},
					issuer: "taba",
					audience: "er",
					expires: DateTime.Now.AddDays(1),
					signingCredentials: new SigningCredentials(new SymmetricSecurityKey(Encoding.UTF8.GetBytes("balabalabalabala")), SecurityAlgorithms.HmacSha256)));
			
			效验 ToKen：
				在这里效验 ToKen 变成了中间件的方式(在方法或者控制器上打 Net Core 内置特性 [Authorize],该方式是无状态的,即无论什么角色都可以访问,另一种 [Authorize(Roles="Admin") 代表只有 Admin 角色才可以使用]),效验JWT时 颁发者、订阅者、数字签名、必须一样才能通过验证
				注册服务：
					services.AddAuthentication("Bearer")		--开启 Bearer 验证
						.AddJwtBearer(b =>		--注册JWT服务
						b.TokenValidationParameters = new TokenValidationParameters()	--参数效验配置
						{
							ValidateIssuerSigningKey = true,	--是否开启对数字签名的效验
							ValidateIssuer = true,				--是否开启对颁发者的效验
							ValidateAudience = true,			--是否开启对订阅者的效验
							ValidIssuer = "taba",				--配置颁发者信息
							ValidAudience = "er",				--配置订阅者信息
							IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes("balabalabalabala"))		--配置数字签名的信息
						});
						
				开启中间件：app.UseAuthentication();
			
			在API中获取 Token值的方法：User.FindFirst(d => d.Type == ClaimTypes.Name).Value,其原理是 客户端请求会携带 Bearer ,Net Core 会将 HttpContext 中获取到的 Bearer 解析,并放入 User.Claims 属性中
			
			注意事项：因为 JWT 和 Net Core 内置的 Claim 字段名会有冲突,Net Core 中 Claim配置映射 会将 JWT 中的 Payload 的字段名替换掉,在注册 JWT 服务之前加上这么一行代码 JwtSecurityTokenHandler.DefaultInboundClaimTypeMap.Clear() 取消 Net Core 的映射
			
5.属性路由
	[Route("[controller]")]
    public class AboutController
    {
        public AboutController()
        {
        }

        [Route("")]				--此处留空的话那么当前Action为默认页面
        public string Phone()
        {
            return "+10086"; 
        }  

        [Route("[action]")]
        public string Country()
        {
            return "中国"; 
        }
    }
	
6.ActionResult
	子类：
		ContentResult			返回一串字符串
		FileContentResult		返回文件的内容
		FilePathResult			返回路径文件的内容
		FileStreamResult		返回流文件的内容
		EmptyResult				返回空
		JavaScriptResult		返回一段 JavaScript 代码
		JsonResult				返回 JSON 格式的数据
		RedirectToResult		重定向到某个 URL
		HttpUnauthorizedResult	返回 403 未授权状态码
		RedirectToRouteResult	重定向到不同的控制器或方法
		ViewResult				从视图引擎中返回一个响应
		PartialViewResult		从视图引擎中返回一个响应
		
7.EntityFrameWork
	注册服务：
		