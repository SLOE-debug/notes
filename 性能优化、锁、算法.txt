1.程序方面性能优化
	数据结构：
		数组：时间复杂度O(n),100万个数据进行处理,那么就是循环100万次
			优点：适合循环处理,按顺序存放数据、查找数据
			缺点：不知道数组长度的话,占用过多空间或者空间不够,插入数据也不方便,
		
		链表：时间复杂度O(n),因为B节点的地址存放于A节点中,需要拿到A节点才能够读取下一个的B节点值
			优点：灵活,插入数据(插入时先扯断链表,在其中某个位置放入元素,然后再连接上链表)
			缺点：不能随机访问,想要访问第五个,那么只能从第一个数到第五个
			
		二叉树：时间复杂度O(n),树结构就是为了方便查找而创造出来的,1000条数据跟100万条数据的层级高度(高度就是指的层级)只差30倍,寻找指定目标访问层级次数,1000条数据就是32次,100万条数据就是1000次
			二叉树是常用的,通用的,其次还有 N叉树 ,N叉树 是为了减少调用次数而出现的,当数据放在硬盘中时,建议使用 N叉树,还有 红黑树,尽量保持各分叉平衡的多叉树,只在树的叶子节点存放数据
			优点：可以不用查询无关的数据,想查找树右边的数据,那么就排除掉了树左边的数据,范围在逐渐缩小
			缺点：数据更新不方便,想更新数据就要删除数据再插入到指定的位置,但是删除的数据通常并不会被填充,当空闲的的数据增多时,那么性能将随即变差,总是放入相同的数据,那么特定位置的分支将逐渐增多,那么树的平衡被破坏了,同样也会造成性能变差
			
		散列算法：复杂度O(1),只需要一次计算就可以找出数据
			散列计算：对相同数据类型的数据取余,得到的余数0~9即数组的下标
				例：1、5、9、8、15、28、102、98、42、64
			优点：无论数据量怎么增加,都可以在一定时间内获取,消除不平衡性的效果
			缺点：对于相同的数据,会发生散列值碰撞(18,28这两个值取余结果都是8)
				散列值碰撞解决方案：用链表的方式将碰撞后的数据给链接起来 或者 重散列
		
		队列：适用于按顺序处理工作,先进先出
			优点：大量的处理涌入的时候,可以先将其放入队列,用于多个系统之间的连接点,还可以作为缓冲
			缺点：并不适用那些需要实时响应的处理,想要获取结果,就要再重新访问一次
	
	缓存：计算机中,CPU也是有缓存的,缓存是为了提高性能而保存的东西
		缓存方式：
			回写：
				更新数据时,先更新缓存再更新实际的存放数据的地方,回写的好处就是不用等待更新数据库,所以数据很快
			直写：
				跟回写相反,直写的方式是先更新数据库,再更新缓存,以避免缓存丢失以后,数据不一致的问题,但速度会比回写慢
				
	锁：行锁,表锁,编程语言中也有锁,琐是在并行处理的情况下,必须的机制
		链表结构中A想要在1和4之间插入数据2,B想要在1和4之间插入数据3,那么最终结果就是链表会被破坏掉,那么锁存在的意义就是让别的程序等待,即在某个处理进行期间起到保护作用
		除了数组的更新之外,其他数据结构都要用到锁来保护,如果说只有一个线程在操作,那么不用锁也可以
		读取的时候可能也需要加锁,如果读取一个值以后,同时有另一个线程对这个值进行了更新,那么读取到的就是一个旧值
		
		锁等待的时候会发生什么事：
			当等待一个锁被释放时,访问数量增长,那么等待时间会以指数级别增长,锁保护时,只要处理没有完成,就不能释放锁,最基本的解决办法,就是让受保护的处理尽快完成
			表锁的话,减少占用锁的时间,
			分割锁,将表锁改为行锁,细化颗粒
			考虑性能时,还要考虑响应和吞吐量
				响应：表示应答的快慢
				吞吐：表示处理数量的多少
				在实际的环境中,有的系统偏重响应(相应变快的话,一般来说吞吐也会变大),有的系统偏重吞吐
				
