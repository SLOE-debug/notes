[TOC]

## 理论

​	非聚集索引包含索引键值和指向表数据存储位置的行定位器。 可以对表或索引视图创建多个非聚集索引。 通常，设计非聚集索引是为改善经常使用的、没有建立聚集索引的查询的性能

​	查询优化器在搜索数据值时，先搜索非聚集索引以找到数据值在表中的位置，然后直接从该位置检索数据。 这使非聚集索引成为完全匹配查询的最佳选择，因为索引包含说明查询所搜索的数据值在表中的精确位置的项。

非聚集索引与聚集索引具有相同的 B 树结构，它们之间的显著差别在于以下两点：

* 基础表的数据行不按非聚集键的顺序排序和存储。

  > 聚集索引是老大，非聚集索引要听老大的，老大说站哪就站哪

* 非聚集索引的叶级别是由索引页而不是由数据页组成。

非聚集索引行中的行定位器或是指向行的指针，或是行的聚集索引键，如下所述：

- 如果表是堆（意味着该表没有聚集索引），则行定位器是指向行的指针。 该指针由文件标识符 (ID)、页码和页上的行数生成。 整个指针称为行 ID (RID)。
- 如果表有聚集索引或索引视图上有聚集索引，则行定位器是行的聚集索引键

#### 模拟非聚集索引结构：

```json
{
  "root": {
    "level": {
      "途径无限个level": {
        // 该表没有聚集索引将存RID
        "pages": [
          {
            "RID": 0
          },
          {
            "RID": 5
          }
        ],
        // 或者 pages 是聚集索引键
        // 假设zhagnsan和lisi是聚集索引键
        "pages": ["zhangsan", "lisi"]
      }
    }
  }
}

```

#### 应遵守的数据库准则

* 更新要求较低但包含大量数据的数据库或表可以`从许多非聚集索引中获益`从而`改善查询性能`。 与全表非聚集索引相比，考虑`为定义完善的数据子集创建筛选索引可以提高查询性能`、降低索引存储开销并减少索引维护开销。
* 联机事务处理 (OLTP) 应用程序和包含经常更新的表的数据库应避免过多索引。 此外，索引应该是窄的，即列越少越好。

#### 应遵守的查询准则

考虑对具有以下属性的查询使用非聚集索引：

* 使用 `JOIN` 或 `GROUP BY` 子句

  > 应为联接和分组操作中所涉及的列创建多个非聚集索引，为任何外键列创建一个聚集索引

* 不返回大型结果集的查询

  > 创建筛选索引以覆盖从大型表中返回定义完善的行子集的查询
  >
  > 也就是说返回大型结果集时，不应该使用非聚集索引，而是使用筛选索引

* 包含经常包含在查询的搜索条件（例如返回完全匹配的 WHERE 子句）中的列

  > 也就是说一下语句中的 name、age、id 这些完全匹配的列，为他们设置非聚集索引
  >
  > ```sql
  > select name,age,id from student where name = '张三' and age = 15 and id = 0
  > ```

#### 应遵守的列准则

考虑具有以下一个或多个属性的列：

* 覆盖查询。

  > 当索引包含查询中的所有列时，性能可以提升。查询优化器可以找到索引内的所有列值；不会访问表或聚集索引数据，这样就减少了磁盘 I/O 操作。 使用具有`包含列`的索引来添加覆盖列，而不是创建宽索引键。如果表中有聚集索引，那么他会将该聚集索引中定义的列自动追加到非聚集索引后面，不用手动指定在非聚集索引中，假如一个表中，聚集索引是 c，那么通过 b、a 列生成的非聚集索引将具有 b、a、c 三个列。
  >
  > 那么当查询 select a,b,c from table 时，这可以生成覆盖查询
  >
  > 也就是说我添加了 name、age、id 三个列为索引建，那么我如果只查 name、age、id 时，这就叫做覆盖查询，但不要一味的用宽索引建（也就是一个索引涉及多个列），而是使用包含列来实现覆盖查询
  >
  > 所以，为查询比较多的列添加包含列索引

* 大量非重复值，如姓氏和名字的组合（前提是这些列不是聚集索引）

  > 如果只有很少的非重复值，比如只有 0 和 1两种，0占多数，那么可以考虑对该列创建筛选索引，查询优化器将对值为1的进行筛选

#### 使用包含列扩展非聚集索引

可以通过将非键列添加到非聚集索引的叶级，扩展非聚集索引的功能，通过包含非键列，可以创建覆盖更多查询（此处的更多查询，指的是 select name,... from table或select age,... from table 的查询组合）的非聚集索引

作为非键列有以下好处：

* 它们可以是不允许作为索引键列的数据类型
* 在计算索引键列数或索引键大小时， 数据库引擎 不考虑它们

当一个索引中包含列多时，也就减少了查询器额外去查询其他列的需要，这样一来，减少了IO，显著提高性能

#### 使用包含列来避开此限制

非聚集索引中，最大键列数为 16，最大索引键大小为 900 字节

比如一个非聚集索引包含以下三个列

* Title nvarchar(50)
* Revision nchar(5)
* FileName nvarchar(400)

因为 **nchar** 和 **nvarchar** 数据类型的每个字符需要 2 个字节，所以包含这三列的索引将超出 900 字节的大小限制 10 个字节 (455 * 2)。

这时将 FileName 设置为包含列，索引大小将为 55 * 2

#### 注意事项

避免添加不必要的列。 添加过多的索引列（键列或非键列）会对性能产生下列影响：

* 一页上能容纳的索引行将更少。 这样会使 I/O 增加并降低缓存效率。
* 需要更多的磁盘空间来存储索引。 特别是，将 **varchar(max)** 、 **nvarchar(max)** 、 **varbinary(max)** 或 **xml** 数据类型添加为非键索引列会显著增加磁盘空间要求。 这是因为列值被复制到了索引叶级别。 因此，它们既驻留在索引中，也驻留在基表中。
* 索引维护可能会增加对基础表或索引视图执行修改、插入、更新或删除操作所需的时间。

您应该确定修改数据时在查询性能上的提升是否超过了对性能的影响，以及是否需要额外的磁盘空间要求

不要为了光图查询优化，而修改、插入、更新，耗时超过了优化的时间

