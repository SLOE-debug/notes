### 锁

#### 简介

锁的存在是为了让数据保持一致性，假如一个多用户系统，用户A的在花钱的同时，用户B获取了用户A的钱数，当用户A花完后，用户B得到的就是旧数据，这时候用户B这边的逻辑就是错的，这时候就需要锁了。

例如：当一行在修改时，将获取锁并将当前行锁住，其他会话访问该行时，将会等待锁被释放才可执行，否则将会一直等待。

当多个用户一起使用系统时（即：并发时），很容易出现超时、死锁等其它问题，导致代码开始出错，并且无法复现错误。

> 死锁：双方都在等待对方释放锁，这时候就会变成死锁。
>
> 超时：即死锁发生时，无法获取数据，等待超时。

锁的意义：

- 锁是一种保证数据一致性的机制。
- 锁可以应用于行级、页级、表级和数据库级

一般我们并不获取锁，而是由MSSQL的锁管理器管理锁。

MSSQL的最小工作单元就是事务，一条语句也是事务（隐式事务）。

一般MSSQL对于可能存在互相影响的语句，会根据时间顺序执行，前者会对当前语句涉及的行获取锁，并锁住行，后者将等待锁被释放再执行。

#### 读现象

ISO SQL 92 标准描述了一下三种不同的“读现象”

##### 脏读

查询语句读取出来的内容是旧的，这成为脏读。

在事务1执行修改期间，事务2读取到了该行的数据，但是事务1未提交而是回滚了，这时候事务2拿到的就是不正确的数据。

##### 不可重复读

两个一样的查询语句查询出不同的值，这成为不可重复读。

当事务1进行读取时，第一次读取后，事务2执行了更新，那么接下来事务1读取时，将会和第一次读取的结果不同。

##### 幻读

两个一样的查询语句查询出不同的结果集，这称为幻读。

事务1在第一个查询语句后，事务2插入或删除了行，事务2再次读取时，将会缺少或增多行。

#### 锁类型

SqlServer有将近20多种锁类型，我们只关注主要的那些：

* 共享锁（S）：在操作（如SELECT）期间获取的那些锁，只在少数情况下不会获取

* 排它锁（X）：在修改操作（插入、更新、删除）期间获取的那些锁，这些锁防止一个对象被不同的会话修改或读取，从获取一直到事务结束才释放。

* 更新锁（U）：是共享锁和排它锁的混合体。

  > 例：update t c1 = 100 where c1 is null
  >
  > 这个语句将会对 t 表中符合条件的那些行将 更新锁 转换为 排它锁。其余的将是 共享锁

* 意图锁（IS、IX、IU等）：这些锁表示对子对象的锁。

  > 例：如果行有 排它锁，则会在页、表、数据库级别引入 IX 锁，这些锁的目的就是优化，描述了锁的信息，这样就不用遍历所有的行去看看它有没有被锁定了。

我们要记住以下锁的兼容性

1. 共享锁与共享锁和更新锁兼容
2. 排它锁与任何锁都不兼容
3. 更新锁与共享锁兼容但与更新锁不兼容

