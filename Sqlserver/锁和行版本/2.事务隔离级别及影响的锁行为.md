### 事务隔离级别

事务的要求是 `ACID` 规范：

* A：原子性（即：全有或全无），要么保存所有更改，要么不保存所有更改
* C：一致性，数据应始终处于一致。
* I：隔离，也就是说，事务中包含5行语句，已经走了3行，但是在事务完成前，其余语句看不到相应的更改。
* D：耐用性，事务应该存活并从系统故障中恢复。

#### 对于MSSQL事务的一些误解

* 如果在没有 begin tran/commit 语句的情况下调用 insert/update/delete 语句，它将形成隐式事务。而且这种隐式事务对于显示事务来说，成本也将非常高。
* 对于 SELECT 语句将会使用较轻的事务。
* (NOLOCK) 提示将读取器降级为读取未提交的隔离级别，但事务仍在进行中。

每个事务都以`特定的事务隔离级别`开始，我们来看一下所有的隔离级别：

#### 4个"悲观"级别

* 未提交读（Read uncommitted）
* 已提交读（read committed）
* 可重复读（repeatable read）
* 可序列化（serializable）

悲观隔离级别， 写入器总是会阻止写入器，并且通常会阻止读取器（读取未提交隔离级别除外）。

即：修改操作会阻止修改操作，并且还会阻止读取操作。

#### 2个“乐观”级别

* 快照（Snapshot）
* 读已提交快照（read committed snapshot）

乐观隔离级别写入者不会阻止读取者，而快照隔离级别不会阻止写入者。

即：修改操作不会阻止读取操作，而且快照级别也不会阻止修改操作（两个会话修改同一行时，将会冲突）。

#### 不同级别对于锁的影响

无论隔离级别如何，排它锁始终保持到事务结束。

* 未提交读

  > 该模式下 SELECT 将不会获取共享锁。因此这些行就算持有 排它锁，那么 SELECT 语句也可以读取由其他未提交事务的修改数据，对于查询出来的结果可能产生负作用，但他只会影响 共享锁 的行为，修改操作仍会相互阻止。

* 已提交读

  > 该模式下会立即获取共享锁并释放锁。

* 可重复读

  > 该模式下会获取共享锁并保持到事务结束，因此他可以防止其他会话在读取后修改数据。

* 可序列化

  > 该模式与可重复读类似，不过在行内获取锁后，其他会话一旦读取数据，它将阻止在中间插入其他数据

* 其他

  > 其他模式下将会获取锁并阻塞会话，等获取到的锁事务结束后，才会返回结果。

#### 事务隔离级别表提示

* 未提交读（NOLOCK）
* 已提交读（READCOMMITTED）
* 可重复读（REPEATABLEREAD）
* 可序列化（HOLDLOCK）

```sql
SELECT * FROM t WITH({Table Hint})
```

